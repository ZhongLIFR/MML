/*
 * generated by Xtext 2.17.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.mml.AllVariables;
import org.xtext.example.mydsl.mml.CSVParsingConfiguration;
import org.xtext.example.mydsl.mml.DT;
import org.xtext.example.mydsl.mml.DataInput;
import org.xtext.example.mydsl.mml.FormulaItem;
import org.xtext.example.mydsl.mml.LogisticRegression;
import org.xtext.example.mydsl.mml.MLChoiceAlgorithm;
import org.xtext.example.mydsl.mml.MMLModel;
import org.xtext.example.mydsl.mml.MmlPackage;
import org.xtext.example.mydsl.mml.PREAMBULE;
import org.xtext.example.mydsl.mml.PredictorVariables;
import org.xtext.example.mydsl.mml.RFormula;
import org.xtext.example.mydsl.mml.RandomForest;
import org.xtext.example.mydsl.mml.SVM;
import org.xtext.example.mydsl.mml.TrainingTest;
import org.xtext.example.mydsl.mml.Validation;
import org.xtext.example.mydsl.services.MmlGrammarAccess;

@SuppressWarnings("all")
public class MmlSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MmlGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MmlPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MmlPackage.ALL_VARIABLES:
				sequence_AllVariables(context, (AllVariables) semanticObject); 
				return; 
			case MmlPackage.CSV_PARSING_CONFIGURATION:
				sequence_CSVParsingConfiguration(context, (CSVParsingConfiguration) semanticObject); 
				return; 
			case MmlPackage.DT:
				sequence_DT(context, (DT) semanticObject); 
				return; 
			case MmlPackage.DATA_INPUT:
				sequence_DataInput(context, (DataInput) semanticObject); 
				return; 
			case MmlPackage.FORMULA_ITEM:
				sequence_FormulaItem(context, (FormulaItem) semanticObject); 
				return; 
			case MmlPackage.LOGISTIC_REGRESSION:
				sequence_LogisticRegression(context, (LogisticRegression) semanticObject); 
				return; 
			case MmlPackage.ML_CHOICE_ALGORITHM:
				sequence_MLChoiceAlgorithm(context, (MLChoiceAlgorithm) semanticObject); 
				return; 
			case MmlPackage.MML_MODEL:
				sequence_MMLModel(context, (MMLModel) semanticObject); 
				return; 
			case MmlPackage.PREAMBULE:
				sequence_PREAMBULE(context, (PREAMBULE) semanticObject); 
				return; 
			case MmlPackage.PREDICTOR_VARIABLES:
				sequence_PredictorVariables(context, (PredictorVariables) semanticObject); 
				return; 
			case MmlPackage.RFORMULA:
				sequence_RFormula(context, (RFormula) semanticObject); 
				return; 
			case MmlPackage.RANDOM_FOREST:
				sequence_RandomForest(context, (RandomForest) semanticObject); 
				return; 
			case MmlPackage.SVM:
				sequence_SVM(context, (SVM) semanticObject); 
				return; 
			case MmlPackage.TRAINING_TEST:
				sequence_TrainingTest(context, (TrainingTest) semanticObject); 
				return; 
			case MmlPackage.VALIDATION:
				sequence_Validation(context, (Validation) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     XFormula returns AllVariables
	 *     AllVariables returns AllVariables
	 *
	 * Constraint:
	 *     (name='all' all='.')
	 */
	protected void sequence_AllVariables(ISerializationContext context, AllVariables semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MmlPackage.Literals.XFORMULA__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MmlPackage.Literals.XFORMULA__NAME));
			if (transientValues.isValueTransient(semanticObject, MmlPackage.Literals.ALL_VARIABLES__ALL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MmlPackage.Literals.ALL_VARIABLES__ALL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAllVariablesAccess().getNameAllKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAllVariablesAccess().getAllFullStopKeyword_1_0(), semanticObject.getAll());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CSVParsingConfiguration returns CSVParsingConfiguration
	 *
	 * Constraint:
	 *     sep=CSVSeparator
	 */
	protected void sequence_CSVParsingConfiguration(ISerializationContext context, CSVParsingConfiguration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MmlPackage.Literals.CSV_PARSING_CONFIGURATION__SEP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MmlPackage.Literals.CSV_PARSING_CONFIGURATION__SEP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCSVParsingConfigurationAccess().getSepCSVSeparatorEnumRuleCall_1_0(), semanticObject.getSep());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MLAlgorithm returns DT
	 *     DT returns DT
	 *
	 * Constraint:
	 *     (name='DT' max_depth=INT?)
	 */
	protected void sequence_DT(ISerializationContext context, DT semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DataInput returns DataInput
	 *
	 * Constraint:
	 *     (filelocation=STRING parsingInstruction=CSVParsingConfiguration?)
	 */
	protected void sequence_DataInput(ISerializationContext context, DataInput semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FormulaItem returns FormulaItem
	 *
	 * Constraint:
	 *     (column=INT | colName=STRING)
	 */
	protected void sequence_FormulaItem(ISerializationContext context, FormulaItem semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MLAlgorithm returns LogisticRegression
	 *     LogisticRegression returns LogisticRegression
	 *
	 * Constraint:
	 *     (name='LogisticRegression' class=CLASS)
	 */
	protected void sequence_LogisticRegression(ISerializationContext context, LogisticRegression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MmlPackage.Literals.ML_ALGORITHM__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MmlPackage.Literals.ML_ALGORITHM__NAME));
			if (transientValues.isValueTransient(semanticObject, MmlPackage.Literals.LOGISTIC_REGRESSION__CLASS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MmlPackage.Literals.LOGISTIC_REGRESSION__CLASS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLogisticRegressionAccess().getNameLogisticRegressionKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLogisticRegressionAccess().getClassCLASSEnumRuleCall_2_0(), semanticObject.getClass_());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MLChoiceAlgorithm returns MLChoiceAlgorithm
	 *
	 * Constraint:
	 *     (framework=FrameworkLang algorithm=MLAlgorithm)
	 */
	protected void sequence_MLChoiceAlgorithm(ISerializationContext context, MLChoiceAlgorithm semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MmlPackage.Literals.ML_CHOICE_ALGORITHM__FRAMEWORK) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MmlPackage.Literals.ML_CHOICE_ALGORITHM__FRAMEWORK));
			if (transientValues.isValueTransient(semanticObject, MmlPackage.Literals.ML_CHOICE_ALGORITHM__ALGORITHM) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MmlPackage.Literals.ML_CHOICE_ALGORITHM__ALGORITHM));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMLChoiceAlgorithmAccess().getFrameworkFrameworkLangEnumRuleCall_1_0(), semanticObject.getFramework());
		feeder.accept(grammarAccess.getMLChoiceAlgorithmAccess().getAlgorithmMLAlgorithmParserRuleCall_3_0(), semanticObject.getAlgorithm());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MMLModel returns MMLModel
	 *
	 * Constraint:
	 *     (pream=PREAMBULE? input=DataInput? algorithm=MLChoiceAlgorithm? formula=RFormula? validation=Validation)
	 */
	protected void sequence_MMLModel(ISerializationContext context, MMLModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PREAMBULE returns PREAMBULE
	 *
	 * Constraint:
	 *     nomProgramme=ID
	 */
	protected void sequence_PREAMBULE(ISerializationContext context, PREAMBULE semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MmlPackage.Literals.PREAMBULE__NOM_PROGRAMME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MmlPackage.Literals.PREAMBULE__NOM_PROGRAMME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPREAMBULEAccess().getNomProgrammeIDTerminalRuleCall_0(), semanticObject.getNomProgramme());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     XFormula returns PredictorVariables
	 *     PredictorVariables returns PredictorVariables
	 *
	 * Constraint:
	 *     (name='PredictorVariables' vars+=FormulaItem vars+=FormulaItem*)
	 */
	protected void sequence_PredictorVariables(ISerializationContext context, PredictorVariables semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     RFormula returns RFormula
	 *
	 * Constraint:
	 *     (predictive=FormulaItem? predictors=XFormula)
	 */
	protected void sequence_RFormula(ISerializationContext context, RFormula semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MLAlgorithm returns RandomForest
	 *     RandomForest returns RandomForest
	 *
	 * Constraint:
	 *     (name='RandomForest' ntree=INT)
	 */
	protected void sequence_RandomForest(ISerializationContext context, RandomForest semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MmlPackage.Literals.ML_ALGORITHM__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MmlPackage.Literals.ML_ALGORITHM__NAME));
			if (transientValues.isValueTransient(semanticObject, MmlPackage.Literals.RANDOM_FOREST__NTREE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MmlPackage.Literals.RANDOM_FOREST__NTREE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRandomForestAccess().getNameRandomForestKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getRandomForestAccess().getNtreeINTTerminalRuleCall_1_0(), semanticObject.getNtree());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MLAlgorithm returns SVM
	 *     SVM returns SVM
	 *
	 * Constraint:
	 *     (name='SVM' gamma=FLOAT? C=FLOAT? kernel=SVMKernel? svmclassification=SVMClassification?)
	 */
	protected void sequence_SVM(ISerializationContext context, SVM semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     StratificationMethod returns TrainingTest
	 *     TrainingTest returns TrainingTest
	 *
	 * Constraint:
	 *     (name='TrainingTest' number=FLOAT)
	 */
	protected void sequence_TrainingTest(ISerializationContext context, TrainingTest semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MmlPackage.Literals.TRAINING_TEST__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MmlPackage.Literals.TRAINING_TEST__NAME));
			if (transientValues.isValueTransient(semanticObject, MmlPackage.Literals.TRAINING_TEST__NUMBER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MmlPackage.Literals.TRAINING_TEST__NUMBER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTrainingTestAccess().getNameTrainingTestKeyword_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getTrainingTestAccess().getNumberFLOATParserRuleCall_3_0(), semanticObject.getNumber());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Validation returns Validation
	 *
	 * Constraint:
	 *     (stratification=StratificationMethod metric+=ValidationMetric+)
	 */
	protected void sequence_Validation(ISerializationContext context, Validation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
