/*
 * generated by Xtext 2.17.0
 */
package org.xtext.example.mydsl.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractEnumRuleElementFinder;
import org.eclipse.xtext.service.AbstractElementFinder.AbstractGrammarElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class MmlGrammarAccess extends AbstractGrammarElementFinder {
	
	public class MMLModelElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.MMLModel");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cModelKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cPreamAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPreamPREAMBULEParserRuleCall_1_0 = (RuleCall)cPreamAssignment_1.eContents().get(0);
		private final Assignment cInputAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cInputDataInputParserRuleCall_2_0 = (RuleCall)cInputAssignment_2.eContents().get(0);
		private final Assignment cAlgorithmAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cAlgorithmMLChoiceAlgorithmParserRuleCall_3_0 = (RuleCall)cAlgorithmAssignment_3.eContents().get(0);
		private final Assignment cFormulaAssignment_4 = (Assignment)cGroup.eContents().get(4);
		private final RuleCall cFormulaRFormulaParserRuleCall_4_0 = (RuleCall)cFormulaAssignment_4.eContents().get(0);
		private final Assignment cValidationAssignment_5 = (Assignment)cGroup.eContents().get(5);
		private final RuleCall cValidationValidationParserRuleCall_5_0 = (RuleCall)cValidationAssignment_5.eContents().get(0);
		private final Keyword cEndKeyword_6 = (Keyword)cGroup.eContents().get(6);
		
		//MMLModel:
		//	"Model:" pream=PREAMBULE?
		//	input=DataInput?
		//	algorithm=MLChoiceAlgorithm?
		//	formula=RFormula?
		//	validation=Validation
		//	"End.";
		@Override public ParserRule getRule() { return rule; }
		
		//"Model:" pream=PREAMBULE? input=DataInput? algorithm=MLChoiceAlgorithm? formula=RFormula? validation=Validation "End."
		public Group getGroup() { return cGroup; }
		
		//"Model:"
		public Keyword getModelKeyword_0() { return cModelKeyword_0; }
		
		//pream=PREAMBULE?
		public Assignment getPreamAssignment_1() { return cPreamAssignment_1; }
		
		//PREAMBULE
		public RuleCall getPreamPREAMBULEParserRuleCall_1_0() { return cPreamPREAMBULEParserRuleCall_1_0; }
		
		//input=DataInput?
		public Assignment getInputAssignment_2() { return cInputAssignment_2; }
		
		//DataInput
		public RuleCall getInputDataInputParserRuleCall_2_0() { return cInputDataInputParserRuleCall_2_0; }
		
		//algorithm=MLChoiceAlgorithm?
		public Assignment getAlgorithmAssignment_3() { return cAlgorithmAssignment_3; }
		
		//MLChoiceAlgorithm
		public RuleCall getAlgorithmMLChoiceAlgorithmParserRuleCall_3_0() { return cAlgorithmMLChoiceAlgorithmParserRuleCall_3_0; }
		
		//formula=RFormula?
		public Assignment getFormulaAssignment_4() { return cFormulaAssignment_4; }
		
		//RFormula
		public RuleCall getFormulaRFormulaParserRuleCall_4_0() { return cFormulaRFormulaParserRuleCall_4_0; }
		
		//validation=Validation
		public Assignment getValidationAssignment_5() { return cValidationAssignment_5; }
		
		//Validation
		public RuleCall getValidationValidationParserRuleCall_5_0() { return cValidationValidationParserRuleCall_5_0; }
		
		//"End."
		public Keyword getEndKeyword_6() { return cEndKeyword_6; }
	}
	public class PREAMBULEElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.PREAMBULE");
		private final Assignment cNomProgrammeAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cNomProgrammeIDTerminalRuleCall_0 = (RuleCall)cNomProgrammeAssignment.eContents().get(0);
		
		//PREAMBULE:
		//	nomProgramme=ID;
		@Override public ParserRule getRule() { return rule; }
		
		//nomProgramme=ID
		public Assignment getNomProgrammeAssignment() { return cNomProgrammeAssignment; }
		
		//ID
		public RuleCall getNomProgrammeIDTerminalRuleCall_0() { return cNomProgrammeIDTerminalRuleCall_0; }
	}
	public class DataInputElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.DataInput");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cDatainputKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cFilelocationAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFilelocationSTRINGTerminalRuleCall_1_0 = (RuleCall)cFilelocationAssignment_1.eContents().get(0);
		private final Assignment cParsingInstructionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cParsingInstructionCSVParsingConfigurationParserRuleCall_2_0 = (RuleCall)cParsingInstructionAssignment_2.eContents().get(0);
		
		///*
		// * mini DSL to read data (here CSV)
		// * mini CSV DSL
		// */ DataInput:
		//	'datainput' filelocation=STRING parsingInstruction=CSVParsingConfiguration?;
		@Override public ParserRule getRule() { return rule; }
		
		//'datainput' filelocation=STRING parsingInstruction=CSVParsingConfiguration?
		public Group getGroup() { return cGroup; }
		
		//'datainput'
		public Keyword getDatainputKeyword_0() { return cDatainputKeyword_0; }
		
		//filelocation=STRING
		public Assignment getFilelocationAssignment_1() { return cFilelocationAssignment_1; }
		
		//STRING
		public RuleCall getFilelocationSTRINGTerminalRuleCall_1_0() { return cFilelocationSTRINGTerminalRuleCall_1_0; }
		
		//parsingInstruction=CSVParsingConfiguration?
		public Assignment getParsingInstructionAssignment_2() { return cParsingInstructionAssignment_2; }
		
		//CSVParsingConfiguration
		public RuleCall getParsingInstructionCSVParsingConfigurationParserRuleCall_2_0() { return cParsingInstructionCSVParsingConfigurationParserRuleCall_2_0; }
	}
	public class CSVParsingConfigurationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.CSVParsingConfiguration");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSeparatorKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cSepAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSepCSVSeparatorEnumRuleCall_1_0 = (RuleCall)cSepAssignment_1.eContents().get(0);
		
		//CSVParsingConfiguration: // we could extend it with quotes handling, encoding format, or even specificities of library used to parse it (eg pandas vs readcsv)
		//	"separator" sep=CSVSeparator;
		@Override public ParserRule getRule() { return rule; }
		
		//// we could extend it with quotes handling, encoding format, or even specificities of library used to parse it (eg pandas vs readcsv)
		//"separator" sep=CSVSeparator
		public Group getGroup() { return cGroup; }
		
		//// we could extend it with quotes handling, encoding format, or even specificities of library used to parse it (eg pandas vs readcsv)
		//"separator"
		public Keyword getSeparatorKeyword_0() { return cSeparatorKeyword_0; }
		
		//sep=CSVSeparator
		public Assignment getSepAssignment_1() { return cSepAssignment_1; }
		
		//CSVSeparator
		public RuleCall getSepCSVSeparatorEnumRuleCall_1_0() { return cSepCSVSeparatorEnumRuleCall_1_0; }
	}
	public class MLChoiceAlgorithmElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.MLChoiceAlgorithm");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cMlframeworkKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cFrameworkAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cFrameworkFrameworkLangEnumRuleCall_1_0 = (RuleCall)cFrameworkAssignment_1.eContents().get(0);
		private final Keyword cAlgorithmKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cAlgorithmAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cAlgorithmMLAlgorithmParserRuleCall_3_0 = (RuleCall)cAlgorithmAssignment_3.eContents().get(0);
		
		///*
		// * mini DSL to select the ML algorithm we want 
		// * we include the choice of the targeted language/framework
		// * ML algorithms can have hyperparameters
		// * 
		// */ MLChoiceAlgorithm:
		//	'mlframework' framework=FrameworkLang
		//	'algorithm' algorithm=MLAlgorithm;
		@Override public ParserRule getRule() { return rule; }
		
		//'mlframework' framework=FrameworkLang 'algorithm' algorithm=MLAlgorithm
		public Group getGroup() { return cGroup; }
		
		//'mlframework'
		public Keyword getMlframeworkKeyword_0() { return cMlframeworkKeyword_0; }
		
		//framework=FrameworkLang
		public Assignment getFrameworkAssignment_1() { return cFrameworkAssignment_1; }
		
		//FrameworkLang
		public RuleCall getFrameworkFrameworkLangEnumRuleCall_1_0() { return cFrameworkFrameworkLangEnumRuleCall_1_0; }
		
		//'algorithm'
		public Keyword getAlgorithmKeyword_2() { return cAlgorithmKeyword_2; }
		
		//algorithm=MLAlgorithm
		public Assignment getAlgorithmAssignment_3() { return cAlgorithmAssignment_3; }
		
		//MLAlgorithm
		public RuleCall getAlgorithmMLAlgorithmParserRuleCall_3_0() { return cAlgorithmMLAlgorithmParserRuleCall_3_0; }
	}
	public class MLAlgorithmElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.MLAlgorithm");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSVMParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cDTParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cRandomForestParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cLogisticRegressionParserRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		
		//MLAlgorithm:
		//	SVM | DT | RandomForest | LogisticRegression;
		@Override public ParserRule getRule() { return rule; }
		
		//SVM | DT | RandomForest | LogisticRegression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//SVM
		public RuleCall getSVMParserRuleCall_0() { return cSVMParserRuleCall_0; }
		
		//DT
		public RuleCall getDTParserRuleCall_1() { return cDTParserRuleCall_1; }
		
		//RandomForest
		public RuleCall getRandomForestParserRuleCall_2() { return cRandomForestParserRuleCall_2; }
		
		//LogisticRegression
		public RuleCall getLogisticRegressionParserRuleCall_3() { return cLogisticRegressionParserRuleCall_3; }
	}
	public class SVMElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.SVM");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameSVMKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cGammaKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cGammaAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cGammaFLOATParserRuleCall_1_1_0 = (RuleCall)cGammaAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cCKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cCAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cCFLOATParserRuleCall_2_1_0 = (RuleCall)cCAssignment_2_1.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final Keyword cKernelKeyword_3_0 = (Keyword)cGroup_3.eContents().get(0);
		private final Assignment cKernelAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cKernelSVMKernelEnumRuleCall_3_1_0 = (RuleCall)cKernelAssignment_3_1.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final Keyword cClassificationKeyword_4_0 = (Keyword)cGroup_4.eContents().get(0);
		private final Assignment cSvmclassificationAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cSvmclassificationSVMClassificationEnumRuleCall_4_1_0 = (RuleCall)cSvmclassificationAssignment_4_1.eContents().get(0);
		
		//SVM:
		//	name='SVM' ('gamma=' gamma=FLOAT)? ('C=' C=FLOAT)? ('kernel=' kernel=SVMKernel)? ('classification'
		//	svmclassification=SVMClassification)?;
		@Override public ParserRule getRule() { return rule; }
		
		//name='SVM' ('gamma=' gamma=FLOAT)? ('C=' C=FLOAT)? ('kernel=' kernel=SVMKernel)? ('classification'
		//svmclassification=SVMClassification)?
		public Group getGroup() { return cGroup; }
		
		//name='SVM'
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//'SVM'
		public Keyword getNameSVMKeyword_0_0() { return cNameSVMKeyword_0_0; }
		
		//('gamma=' gamma=FLOAT)?
		public Group getGroup_1() { return cGroup_1; }
		
		//'gamma='
		public Keyword getGammaKeyword_1_0() { return cGammaKeyword_1_0; }
		
		//gamma=FLOAT
		public Assignment getGammaAssignment_1_1() { return cGammaAssignment_1_1; }
		
		//FLOAT
		public RuleCall getGammaFLOATParserRuleCall_1_1_0() { return cGammaFLOATParserRuleCall_1_1_0; }
		
		//('C=' C=FLOAT)?
		public Group getGroup_2() { return cGroup_2; }
		
		//'C='
		public Keyword getCKeyword_2_0() { return cCKeyword_2_0; }
		
		//C=FLOAT
		public Assignment getCAssignment_2_1() { return cCAssignment_2_1; }
		
		//FLOAT
		public RuleCall getCFLOATParserRuleCall_2_1_0() { return cCFLOATParserRuleCall_2_1_0; }
		
		//('kernel=' kernel=SVMKernel)?
		public Group getGroup_3() { return cGroup_3; }
		
		//'kernel='
		public Keyword getKernelKeyword_3_0() { return cKernelKeyword_3_0; }
		
		//kernel=SVMKernel
		public Assignment getKernelAssignment_3_1() { return cKernelAssignment_3_1; }
		
		//SVMKernel
		public RuleCall getKernelSVMKernelEnumRuleCall_3_1_0() { return cKernelSVMKernelEnumRuleCall_3_1_0; }
		
		//('classification' svmclassification=SVMClassification)?
		public Group getGroup_4() { return cGroup_4; }
		
		//'classification'
		public Keyword getClassificationKeyword_4_0() { return cClassificationKeyword_4_0; }
		
		//svmclassification=SVMClassification
		public Assignment getSvmclassificationAssignment_4_1() { return cSvmclassificationAssignment_4_1; }
		
		//SVMClassification
		public RuleCall getSvmclassificationSVMClassificationEnumRuleCall_4_1_0() { return cSvmclassificationSVMClassificationEnumRuleCall_4_1_0; }
	}
	public class DTElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.DT");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameDTKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Assignment cMax_depthAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cMax_depthINTTerminalRuleCall_1_0 = (RuleCall)cMax_depthAssignment_1.eContents().get(0);
		
		//DT:
		//	name='DT' max_depth=INT?;
		@Override public ParserRule getRule() { return rule; }
		
		//name='DT' max_depth=INT?
		public Group getGroup() { return cGroup; }
		
		//name='DT'
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//'DT'
		public Keyword getNameDTKeyword_0_0() { return cNameDTKeyword_0_0; }
		
		//max_depth=INT?
		public Assignment getMax_depthAssignment_1() { return cMax_depthAssignment_1; }
		
		//INT
		public RuleCall getMax_depthINTTerminalRuleCall_1_0() { return cMax_depthINTTerminalRuleCall_1_0; }
	}
	public class RandomForestElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.RandomForest");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameRandomForestKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Assignment cNtreeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNtreeINTTerminalRuleCall_1_0 = (RuleCall)cNtreeAssignment_1.eContents().get(0);
		
		//RandomForest:
		//	name='RandomForest' ntree=INT;
		@Override public ParserRule getRule() { return rule; }
		
		//name='RandomForest' ntree=INT
		public Group getGroup() { return cGroup; }
		
		//name='RandomForest'
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//'RandomForest'
		public Keyword getNameRandomForestKeyword_0_0() { return cNameRandomForestKeyword_0_0; }
		
		//ntree=INT
		public Assignment getNtreeAssignment_1() { return cNtreeAssignment_1; }
		
		//INT
		public RuleCall getNtreeINTTerminalRuleCall_1_0() { return cNtreeINTTerminalRuleCall_1_0; }
	}
	public class LogisticRegressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.LogisticRegression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameLogisticRegressionKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Keyword cClassKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Assignment cClassAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cClassCLASSEnumRuleCall_2_0 = (RuleCall)cClassAssignment_2.eContents().get(0);
		
		//LogisticRegression:
		//	name='LogisticRegression'
		//	'class=' class=CLASS;
		@Override public ParserRule getRule() { return rule; }
		
		//name='LogisticRegression' 'class=' class=CLASS
		public Group getGroup() { return cGroup; }
		
		//name='LogisticRegression'
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//'LogisticRegression'
		public Keyword getNameLogisticRegressionKeyword_0_0() { return cNameLogisticRegressionKeyword_0_0; }
		
		//'class='
		public Keyword getClassKeyword_1() { return cClassKeyword_1; }
		
		//class=CLASS
		public Assignment getClassAssignment_2() { return cClassAssignment_2; }
		
		//CLASS
		public RuleCall getClassCLASSEnumRuleCall_2_0() { return cClassCLASSEnumRuleCall_2_0; }
	}
	public class FLOATElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.FLOAT");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Keyword cFullStopKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final RuleCall cINTTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		//FLOAT:
		//	INT '.' INT;
		@Override public ParserRule getRule() { return rule; }
		
		//INT '.' INT
		public Group getGroup() { return cGroup; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_0() { return cINTTerminalRuleCall_0; }
		
		//'.'
		public Keyword getFullStopKeyword_1() { return cFullStopKeyword_1; }
		
		//INT
		public RuleCall getINTTerminalRuleCall_2() { return cINTTerminalRuleCall_2; }
	}
	public class RFormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.RFormula");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFormulaKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cPredictiveAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cPredictiveFormulaItemParserRuleCall_1_0_0 = (RuleCall)cPredictiveAssignment_1_0.eContents().get(0);
		private final Keyword cTildeKeyword_1_1 = (Keyword)cGroup_1.eContents().get(1);
		private final Assignment cPredictorsAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cPredictorsXFormulaParserRuleCall_2_0 = (RuleCall)cPredictorsAssignment_2.eContents().get(0);
		
		///*
		// * mini DSL to specify "formula"
		// * inspired from R formula 
		// */ RFormula:
		//	'formula' (predictive=FormulaItem "~")? predictors=XFormula;
		@Override public ParserRule getRule() { return rule; }
		
		//'formula' (predictive=FormulaItem "~")? predictors=XFormula
		public Group getGroup() { return cGroup; }
		
		//'formula'
		public Keyword getFormulaKeyword_0() { return cFormulaKeyword_0; }
		
		//(predictive=FormulaItem "~")?
		public Group getGroup_1() { return cGroup_1; }
		
		//predictive=FormulaItem
		public Assignment getPredictiveAssignment_1_0() { return cPredictiveAssignment_1_0; }
		
		//FormulaItem
		public RuleCall getPredictiveFormulaItemParserRuleCall_1_0_0() { return cPredictiveFormulaItemParserRuleCall_1_0_0; }
		
		//"~"
		public Keyword getTildeKeyword_1_1() { return cTildeKeyword_1_1; }
		
		//predictors=XFormula
		public Assignment getPredictorsAssignment_2() { return cPredictorsAssignment_2; }
		
		//XFormula
		public RuleCall getPredictorsXFormulaParserRuleCall_2_0() { return cPredictorsXFormulaParserRuleCall_2_0; }
	}
	public class XFormulaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.XFormula");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cAllVariablesParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cPredictorVariablesParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//XFormula:
		//	AllVariables | PredictorVariables;
		@Override public ParserRule getRule() { return rule; }
		
		//AllVariables | PredictorVariables
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//AllVariables
		public RuleCall getAllVariablesParserRuleCall_0() { return cAllVariablesParserRuleCall_0; }
		
		//PredictorVariables
		public RuleCall getPredictorVariablesParserRuleCall_1() { return cPredictorVariablesParserRuleCall_1; }
	}
	public class AllVariablesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.AllVariables");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameAllKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Assignment cAllAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final Keyword cAllFullStopKeyword_1_0 = (Keyword)cAllAssignment_1.eContents().get(0);
		
		//AllVariables:
		//	name="all" all='.';
		@Override public ParserRule getRule() { return rule; }
		
		//name="all" all='.'
		public Group getGroup() { return cGroup; }
		
		//name="all"
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//"all"
		public Keyword getNameAllKeyword_0_0() { return cNameAllKeyword_0_0; }
		
		//all='.'
		public Assignment getAllAssignment_1() { return cAllAssignment_1; }
		
		//'.'
		public Keyword getAllFullStopKeyword_1_0() { return cAllFullStopKeyword_1_0; }
	}
	public class PredictorVariablesElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.PredictorVariables");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNamePredictorVariablesKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Assignment cVarsAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cVarsFormulaItemParserRuleCall_1_0_0 = (RuleCall)cVarsAssignment_1_0.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final Keyword cPlusSignKeyword_1_1_0 = (Keyword)cGroup_1_1.eContents().get(0);
		private final Assignment cVarsAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cVarsFormulaItemParserRuleCall_1_1_1_0 = (RuleCall)cVarsAssignment_1_1_1.eContents().get(0);
		
		//PredictorVariables:
		//	name="PredictorVariables" (vars+=FormulaItem ("+" vars+=FormulaItem)*);
		@Override public ParserRule getRule() { return rule; }
		
		//name="PredictorVariables" (vars+=FormulaItem ("+" vars+=FormulaItem)*)
		public Group getGroup() { return cGroup; }
		
		//name="PredictorVariables"
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//"PredictorVariables"
		public Keyword getNamePredictorVariablesKeyword_0_0() { return cNamePredictorVariablesKeyword_0_0; }
		
		//vars+=FormulaItem ("+" vars+=FormulaItem)*
		public Group getGroup_1() { return cGroup_1; }
		
		//vars+=FormulaItem
		public Assignment getVarsAssignment_1_0() { return cVarsAssignment_1_0; }
		
		//FormulaItem
		public RuleCall getVarsFormulaItemParserRuleCall_1_0_0() { return cVarsFormulaItemParserRuleCall_1_0_0; }
		
		//("+" vars+=FormulaItem)*
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//"+"
		public Keyword getPlusSignKeyword_1_1_0() { return cPlusSignKeyword_1_1_0; }
		
		//vars+=FormulaItem
		public Assignment getVarsAssignment_1_1_1() { return cVarsAssignment_1_1_1; }
		
		//FormulaItem
		public RuleCall getVarsFormulaItemParserRuleCall_1_1_1_0() { return cVarsFormulaItemParserRuleCall_1_1_1_0; }
	}
	public class FormulaItemElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.FormulaItem");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cColumnAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cColumnINTTerminalRuleCall_0_0 = (RuleCall)cColumnAssignment_0.eContents().get(0);
		private final Assignment cColNameAssignment_1 = (Assignment)cAlternatives.eContents().get(1);
		private final RuleCall cColNameSTRINGTerminalRuleCall_1_0 = (RuleCall)cColNameAssignment_1.eContents().get(0);
		
		//// by name or integer
		//FormulaItem:
		//	column=INT | colName=STRING;
		@Override public ParserRule getRule() { return rule; }
		
		//column=INT | colName=STRING
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//column=INT
		public Assignment getColumnAssignment_0() { return cColumnAssignment_0; }
		
		//INT
		public RuleCall getColumnINTTerminalRuleCall_0_0() { return cColumnINTTerminalRuleCall_0_0; }
		
		//colName=STRING
		public Assignment getColNameAssignment_1() { return cColNameAssignment_1; }
		
		//STRING
		public RuleCall getColNameSTRINGTerminalRuleCall_1_0() { return cColNameSTRINGTerminalRuleCall_1_0; }
	}
	public class ValidationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.Validation");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cStratificationAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cStratificationStratificationMethodParserRuleCall_0_0 = (RuleCall)cStratificationAssignment_0.eContents().get(0);
		private final Assignment cMetricAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cMetricValidationMetricEnumRuleCall_1_0 = (RuleCall)cMetricAssignment_1.eContents().get(0);
		
		///*
		// * mini DSL for evaluation
		// * choice of a "stratification" strategy and metric
		// */ Validation:
		//	stratification=StratificationMethod
		//	metric+=ValidationMetric+;
		@Override public ParserRule getRule() { return rule; }
		
		//stratification=StratificationMethod metric+=ValidationMetric+
		public Group getGroup() { return cGroup; }
		
		//stratification=StratificationMethod
		public Assignment getStratificationAssignment_0() { return cStratificationAssignment_0; }
		
		//StratificationMethod
		public RuleCall getStratificationStratificationMethodParserRuleCall_0_0() { return cStratificationStratificationMethodParserRuleCall_0_0; }
		
		//metric+=ValidationMetric+
		public Assignment getMetricAssignment_1() { return cMetricAssignment_1; }
		
		//ValidationMetric
		public RuleCall getMetricValidationMetricEnumRuleCall_1_0() { return cMetricValidationMetricEnumRuleCall_1_0; }
	}
	public class StratificationMethodElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.StratificationMethod");
		private final RuleCall cTrainingTestParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		//StratificationMethod:
		//	TrainingTest;
		@Override public ParserRule getRule() { return rule; }
		
		//TrainingTest
		public RuleCall getTrainingTestParserRuleCall() { return cTrainingTestParserRuleCall; }
	}
	public class TrainingTestElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.TrainingTest");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNameAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final Keyword cNameTrainingTestKeyword_0_0 = (Keyword)cNameAssignment_0.eContents().get(0);
		private final Keyword cLeftCurlyBracketKeyword_1 = (Keyword)cGroup.eContents().get(1);
		private final Keyword cPourcentageTrainingKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cNumberAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cNumberFLOATParserRuleCall_3_0 = (RuleCall)cNumberAssignment_3.eContents().get(0);
		private final Keyword cRightCurlyBracketKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		//TrainingTest:
		//	name='TrainingTest' '{'
		//	'pourcentageTraining' number=FLOAT
		//	'}';
		@Override public ParserRule getRule() { return rule; }
		
		//name='TrainingTest' '{' 'pourcentageTraining' number=FLOAT '}'
		public Group getGroup() { return cGroup; }
		
		//name='TrainingTest'
		public Assignment getNameAssignment_0() { return cNameAssignment_0; }
		
		//'TrainingTest'
		public Keyword getNameTrainingTestKeyword_0_0() { return cNameTrainingTestKeyword_0_0; }
		
		//'{'
		public Keyword getLeftCurlyBracketKeyword_1() { return cLeftCurlyBracketKeyword_1; }
		
		//'pourcentageTraining'
		public Keyword getPourcentageTrainingKeyword_2() { return cPourcentageTrainingKeyword_2; }
		
		//number=FLOAT
		public Assignment getNumberAssignment_3() { return cNumberAssignment_3; }
		
		//FLOAT
		public RuleCall getNumberFLOATParserRuleCall_3_0() { return cNumberFLOATParserRuleCall_3_0; }
		
		//'}'
		public Keyword getRightCurlyBracketKeyword_4() { return cRightCurlyBracketKeyword_4; }
	}
	
	public class CSVSeparatorElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.CSVSeparator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cCOMMAEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cCOMMACommaKeyword_0_0 = (Keyword)cCOMMAEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cSEMI_COLONEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cSEMI_COLONSemicolonKeyword_1_0 = (Keyword)cSEMI_COLONEnumLiteralDeclaration_1.eContents().get(0);
		
		//enum CSVSeparator:
		//	COMMA=',' | SEMI_COLON=";";
		public EnumRule getRule() { return rule; }
		
		//COMMA=',' | SEMI_COLON=";"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//COMMA=','
		public EnumLiteralDeclaration getCOMMAEnumLiteralDeclaration_0() { return cCOMMAEnumLiteralDeclaration_0; }
		
		//','
		public Keyword getCOMMACommaKeyword_0_0() { return cCOMMACommaKeyword_0_0; }
		
		//SEMI_COLON=";"
		public EnumLiteralDeclaration getSEMI_COLONEnumLiteralDeclaration_1() { return cSEMI_COLONEnumLiteralDeclaration_1; }
		
		//";"
		public Keyword getSEMI_COLONSemicolonKeyword_1_0() { return cSEMI_COLONSemicolonKeyword_1_0; }
	}
	public class FrameworkLangElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.FrameworkLang");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cSCIKITEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cSCIKITScikitLearnKeyword_0_0 = (Keyword)cSCIKITEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cREnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cRRKeyword_1_0 = (Keyword)cREnumLiteralDeclaration_1.eContents().get(0);
		
		//enum FrameworkLang:
		//	SCIKIT="scikit-learn" | R;
		public EnumRule getRule() { return rule; }
		
		//SCIKIT="scikit-learn" | R
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//SCIKIT="scikit-learn"
		public EnumLiteralDeclaration getSCIKITEnumLiteralDeclaration_0() { return cSCIKITEnumLiteralDeclaration_0; }
		
		//"scikit-learn"
		public Keyword getSCIKITScikitLearnKeyword_0_0() { return cSCIKITScikitLearnKeyword_0_0; }
		
		//R
		public EnumLiteralDeclaration getREnumLiteralDeclaration_1() { return cREnumLiteralDeclaration_1; }
		
		//"R"
		public Keyword getRRKeyword_1_0() { return cRRKeyword_1_0; }
	}
	public class SVMKernelElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.SVMKernel");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cLinearEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cLinearLinearKeyword_0_0 = (Keyword)cLinearEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cPolyEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cPolyPolynomialKeyword_1_0 = (Keyword)cPolyEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cRadialEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cRadialRadialKeyword_2_0 = (Keyword)cRadialEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum SVMKernel:
		//	linear | poly='polynomial' | radial;
		public EnumRule getRule() { return rule; }
		
		//linear | poly='polynomial' | radial
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//linear
		public EnumLiteralDeclaration getLinearEnumLiteralDeclaration_0() { return cLinearEnumLiteralDeclaration_0; }
		
		//'linear'
		public Keyword getLinearLinearKeyword_0_0() { return cLinearLinearKeyword_0_0; }
		
		//poly='polynomial'
		public EnumLiteralDeclaration getPolyEnumLiteralDeclaration_1() { return cPolyEnumLiteralDeclaration_1; }
		
		//'polynomial'
		public Keyword getPolyPolynomialKeyword_1_0() { return cPolyPolynomialKeyword_1_0; }
		
		//radial
		public EnumLiteralDeclaration getRadialEnumLiteralDeclaration_2() { return cRadialEnumLiteralDeclaration_2; }
		
		//'radial'
		public Keyword getRadialRadialKeyword_2_0() { return cRadialRadialKeyword_2_0; }
	}
	public class SVMClassificationElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.SVMClassification");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cCClassEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cCClassCClassificationKeyword_0_0 = (Keyword)cCClassEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cNuClassEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cNuClassNuClassificationKeyword_1_0 = (Keyword)cNuClassEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cOneClassEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cOneClassOneClassificationKeyword_2_0 = (Keyword)cOneClassEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum SVMClassification:
		//	cClass="C-classification" | nuClass="nu-classification" | oneClass="one-classification";
		public EnumRule getRule() { return rule; }
		
		//cClass="C-classification" | nuClass="nu-classification" | oneClass="one-classification"
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//cClass="C-classification"
		public EnumLiteralDeclaration getCClassEnumLiteralDeclaration_0() { return cCClassEnumLiteralDeclaration_0; }
		
		//"C-classification"
		public Keyword getCClassCClassificationKeyword_0_0() { return cCClassCClassificationKeyword_0_0; }
		
		//nuClass="nu-classification"
		public EnumLiteralDeclaration getNuClassEnumLiteralDeclaration_1() { return cNuClassEnumLiteralDeclaration_1; }
		
		//"nu-classification"
		public Keyword getNuClassNuClassificationKeyword_1_0() { return cNuClassNuClassificationKeyword_1_0; }
		
		//oneClass="one-classification"
		public EnumLiteralDeclaration getOneClassEnumLiteralDeclaration_2() { return cOneClassEnumLiteralDeclaration_2; }
		
		//"one-classification"
		public Keyword getOneClassOneClassificationKeyword_2_0() { return cOneClassOneClassificationKeyword_2_0; }
	}
	public class CLASSElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.CLASS");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cBinomialEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cBinomialBinomialKeyword_0_0 = (Keyword)cBinomialEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cGaussianEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cGaussianGaussianKeyword_1_0 = (Keyword)cGaussianEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cPoissonEnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cPoissonPoissonKeyword_2_0 = (Keyword)cPoissonEnumLiteralDeclaration_2.eContents().get(0);
		
		//enum CLASS:
		//	binomial | gaussian | poisson;
		public EnumRule getRule() { return rule; }
		
		//binomial | gaussian | poisson
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//binomial
		public EnumLiteralDeclaration getBinomialEnumLiteralDeclaration_0() { return cBinomialEnumLiteralDeclaration_0; }
		
		//"binomial"
		public Keyword getBinomialBinomialKeyword_0_0() { return cBinomialBinomialKeyword_0_0; }
		
		//gaussian
		public EnumLiteralDeclaration getGaussianEnumLiteralDeclaration_1() { return cGaussianEnumLiteralDeclaration_1; }
		
		//"gaussian"
		public Keyword getGaussianGaussianKeyword_1_0() { return cGaussianGaussianKeyword_1_0; }
		
		//poisson
		public EnumLiteralDeclaration getPoissonEnumLiteralDeclaration_2() { return cPoissonEnumLiteralDeclaration_2; }
		
		//"poisson"
		public Keyword getPoissonPoissonKeyword_2_0() { return cPoissonPoissonKeyword_2_0; }
	}
	public class ValidationMetricElements extends AbstractEnumRuleElementFinder {
		private final EnumRule rule = (EnumRule) GrammarUtil.findRuleForName(getGrammar(), "org.xtext.example.mydsl.Mml.ValidationMetric");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final EnumLiteralDeclaration cRECALLEnumLiteralDeclaration_0 = (EnumLiteralDeclaration)cAlternatives.eContents().get(0);
		private final Keyword cRECALLRecallKeyword_0_0 = (Keyword)cRECALLEnumLiteralDeclaration_0.eContents().get(0);
		private final EnumLiteralDeclaration cPRECISIONEnumLiteralDeclaration_1 = (EnumLiteralDeclaration)cAlternatives.eContents().get(1);
		private final Keyword cPRECISIONPrecisionKeyword_1_0 = (Keyword)cPRECISIONEnumLiteralDeclaration_1.eContents().get(0);
		private final EnumLiteralDeclaration cF1EnumLiteralDeclaration_2 = (EnumLiteralDeclaration)cAlternatives.eContents().get(2);
		private final Keyword cF1F1Keyword_2_0 = (Keyword)cF1EnumLiteralDeclaration_2.eContents().get(0);
		
		//enum ValidationMetric:
		//	RECALL='recall' | PRECISION='precision' | F1;
		public EnumRule getRule() { return rule; }
		
		//RECALL='recall' | PRECISION='precision' | F1
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//RECALL='recall'
		public EnumLiteralDeclaration getRECALLEnumLiteralDeclaration_0() { return cRECALLEnumLiteralDeclaration_0; }
		
		//'recall'
		public Keyword getRECALLRecallKeyword_0_0() { return cRECALLRecallKeyword_0_0; }
		
		//PRECISION='precision'
		public EnumLiteralDeclaration getPRECISIONEnumLiteralDeclaration_1() { return cPRECISIONEnumLiteralDeclaration_1; }
		
		//'precision'
		public Keyword getPRECISIONPrecisionKeyword_1_0() { return cPRECISIONPrecisionKeyword_1_0; }
		
		//F1
		public EnumLiteralDeclaration getF1EnumLiteralDeclaration_2() { return cF1EnumLiteralDeclaration_2; }
		
		//'F1'
		public Keyword getF1F1Keyword_2_0() { return cF1F1Keyword_2_0; }
	}
	
	private final MMLModelElements pMMLModel;
	private final PREAMBULEElements pPREAMBULE;
	private final DataInputElements pDataInput;
	private final CSVParsingConfigurationElements pCSVParsingConfiguration;
	private final CSVSeparatorElements eCSVSeparator;
	private final MLChoiceAlgorithmElements pMLChoiceAlgorithm;
	private final FrameworkLangElements eFrameworkLang;
	private final MLAlgorithmElements pMLAlgorithm;
	private final SVMElements pSVM;
	private final SVMKernelElements eSVMKernel;
	private final SVMClassificationElements eSVMClassification;
	private final DTElements pDT;
	private final RandomForestElements pRandomForest;
	private final LogisticRegressionElements pLogisticRegression;
	private final CLASSElements eCLASS;
	private final FLOATElements pFLOAT;
	private final RFormulaElements pRFormula;
	private final XFormulaElements pXFormula;
	private final AllVariablesElements pAllVariables;
	private final PredictorVariablesElements pPredictorVariables;
	private final FormulaItemElements pFormulaItem;
	private final ValidationElements pValidation;
	private final StratificationMethodElements pStratificationMethod;
	private final TrainingTestElements pTrainingTest;
	private final ValidationMetricElements eValidationMetric;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public MmlGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pMMLModel = new MMLModelElements();
		this.pPREAMBULE = new PREAMBULEElements();
		this.pDataInput = new DataInputElements();
		this.pCSVParsingConfiguration = new CSVParsingConfigurationElements();
		this.eCSVSeparator = new CSVSeparatorElements();
		this.pMLChoiceAlgorithm = new MLChoiceAlgorithmElements();
		this.eFrameworkLang = new FrameworkLangElements();
		this.pMLAlgorithm = new MLAlgorithmElements();
		this.pSVM = new SVMElements();
		this.eSVMKernel = new SVMKernelElements();
		this.eSVMClassification = new SVMClassificationElements();
		this.pDT = new DTElements();
		this.pRandomForest = new RandomForestElements();
		this.pLogisticRegression = new LogisticRegressionElements();
		this.eCLASS = new CLASSElements();
		this.pFLOAT = new FLOATElements();
		this.pRFormula = new RFormulaElements();
		this.pXFormula = new XFormulaElements();
		this.pAllVariables = new AllVariablesElements();
		this.pPredictorVariables = new PredictorVariablesElements();
		this.pFormulaItem = new FormulaItemElements();
		this.pValidation = new ValidationElements();
		this.pStratificationMethod = new StratificationMethodElements();
		this.pTrainingTest = new TrainingTestElements();
		this.eValidationMetric = new ValidationMetricElements();
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.xtext.example.mydsl.Mml".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	//MMLModel:
	//	"Model:" pream=PREAMBULE?
	//	input=DataInput?
	//	algorithm=MLChoiceAlgorithm?
	//	formula=RFormula?
	//	validation=Validation
	//	"End.";
	public MMLModelElements getMMLModelAccess() {
		return pMMLModel;
	}
	
	public ParserRule getMMLModelRule() {
		return getMMLModelAccess().getRule();
	}
	
	//PREAMBULE:
	//	nomProgramme=ID;
	public PREAMBULEElements getPREAMBULEAccess() {
		return pPREAMBULE;
	}
	
	public ParserRule getPREAMBULERule() {
		return getPREAMBULEAccess().getRule();
	}
	
	///*
	// * mini DSL to read data (here CSV)
	// * mini CSV DSL
	// */ DataInput:
	//	'datainput' filelocation=STRING parsingInstruction=CSVParsingConfiguration?;
	public DataInputElements getDataInputAccess() {
		return pDataInput;
	}
	
	public ParserRule getDataInputRule() {
		return getDataInputAccess().getRule();
	}
	
	//CSVParsingConfiguration: // we could extend it with quotes handling, encoding format, or even specificities of library used to parse it (eg pandas vs readcsv)
	//	"separator" sep=CSVSeparator;
	public CSVParsingConfigurationElements getCSVParsingConfigurationAccess() {
		return pCSVParsingConfiguration;
	}
	
	public ParserRule getCSVParsingConfigurationRule() {
		return getCSVParsingConfigurationAccess().getRule();
	}
	
	//enum CSVSeparator:
	//	COMMA=',' | SEMI_COLON=";";
	public CSVSeparatorElements getCSVSeparatorAccess() {
		return eCSVSeparator;
	}
	
	public EnumRule getCSVSeparatorRule() {
		return getCSVSeparatorAccess().getRule();
	}
	
	///*
	// * mini DSL to select the ML algorithm we want 
	// * we include the choice of the targeted language/framework
	// * ML algorithms can have hyperparameters
	// * 
	// */ MLChoiceAlgorithm:
	//	'mlframework' framework=FrameworkLang
	//	'algorithm' algorithm=MLAlgorithm;
	public MLChoiceAlgorithmElements getMLChoiceAlgorithmAccess() {
		return pMLChoiceAlgorithm;
	}
	
	public ParserRule getMLChoiceAlgorithmRule() {
		return getMLChoiceAlgorithmAccess().getRule();
	}
	
	//enum FrameworkLang:
	//	SCIKIT="scikit-learn" | R;
	public FrameworkLangElements getFrameworkLangAccess() {
		return eFrameworkLang;
	}
	
	public EnumRule getFrameworkLangRule() {
		return getFrameworkLangAccess().getRule();
	}
	
	//MLAlgorithm:
	//	SVM | DT | RandomForest | LogisticRegression;
	public MLAlgorithmElements getMLAlgorithmAccess() {
		return pMLAlgorithm;
	}
	
	public ParserRule getMLAlgorithmRule() {
		return getMLAlgorithmAccess().getRule();
	}
	
	//SVM:
	//	name='SVM' ('gamma=' gamma=FLOAT)? ('C=' C=FLOAT)? ('kernel=' kernel=SVMKernel)? ('classification'
	//	svmclassification=SVMClassification)?;
	public SVMElements getSVMAccess() {
		return pSVM;
	}
	
	public ParserRule getSVMRule() {
		return getSVMAccess().getRule();
	}
	
	//enum SVMKernel:
	//	linear | poly='polynomial' | radial;
	public SVMKernelElements getSVMKernelAccess() {
		return eSVMKernel;
	}
	
	public EnumRule getSVMKernelRule() {
		return getSVMKernelAccess().getRule();
	}
	
	//enum SVMClassification:
	//	cClass="C-classification" | nuClass="nu-classification" | oneClass="one-classification";
	public SVMClassificationElements getSVMClassificationAccess() {
		return eSVMClassification;
	}
	
	public EnumRule getSVMClassificationRule() {
		return getSVMClassificationAccess().getRule();
	}
	
	//DT:
	//	name='DT' max_depth=INT?;
	public DTElements getDTAccess() {
		return pDT;
	}
	
	public ParserRule getDTRule() {
		return getDTAccess().getRule();
	}
	
	//RandomForest:
	//	name='RandomForest' ntree=INT;
	public RandomForestElements getRandomForestAccess() {
		return pRandomForest;
	}
	
	public ParserRule getRandomForestRule() {
		return getRandomForestAccess().getRule();
	}
	
	//LogisticRegression:
	//	name='LogisticRegression'
	//	'class=' class=CLASS;
	public LogisticRegressionElements getLogisticRegressionAccess() {
		return pLogisticRegression;
	}
	
	public ParserRule getLogisticRegressionRule() {
		return getLogisticRegressionAccess().getRule();
	}
	
	//enum CLASS:
	//	binomial | gaussian | poisson;
	public CLASSElements getCLASSAccess() {
		return eCLASS;
	}
	
	public EnumRule getCLASSRule() {
		return getCLASSAccess().getRule();
	}
	
	//FLOAT:
	//	INT '.' INT;
	public FLOATElements getFLOATAccess() {
		return pFLOAT;
	}
	
	public ParserRule getFLOATRule() {
		return getFLOATAccess().getRule();
	}
	
	///*
	// * mini DSL to specify "formula"
	// * inspired from R formula 
	// */ RFormula:
	//	'formula' (predictive=FormulaItem "~")? predictors=XFormula;
	public RFormulaElements getRFormulaAccess() {
		return pRFormula;
	}
	
	public ParserRule getRFormulaRule() {
		return getRFormulaAccess().getRule();
	}
	
	//XFormula:
	//	AllVariables | PredictorVariables;
	public XFormulaElements getXFormulaAccess() {
		return pXFormula;
	}
	
	public ParserRule getXFormulaRule() {
		return getXFormulaAccess().getRule();
	}
	
	//AllVariables:
	//	name="all" all='.';
	public AllVariablesElements getAllVariablesAccess() {
		return pAllVariables;
	}
	
	public ParserRule getAllVariablesRule() {
		return getAllVariablesAccess().getRule();
	}
	
	//PredictorVariables:
	//	name="PredictorVariables" (vars+=FormulaItem ("+" vars+=FormulaItem)*);
	public PredictorVariablesElements getPredictorVariablesAccess() {
		return pPredictorVariables;
	}
	
	public ParserRule getPredictorVariablesRule() {
		return getPredictorVariablesAccess().getRule();
	}
	
	//// by name or integer
	//FormulaItem:
	//	column=INT | colName=STRING;
	public FormulaItemElements getFormulaItemAccess() {
		return pFormulaItem;
	}
	
	public ParserRule getFormulaItemRule() {
		return getFormulaItemAccess().getRule();
	}
	
	///*
	// * mini DSL for evaluation
	// * choice of a "stratification" strategy and metric
	// */ Validation:
	//	stratification=StratificationMethod
	//	metric+=ValidationMetric+;
	public ValidationElements getValidationAccess() {
		return pValidation;
	}
	
	public ParserRule getValidationRule() {
		return getValidationAccess().getRule();
	}
	
	//StratificationMethod:
	//	TrainingTest;
	public StratificationMethodElements getStratificationMethodAccess() {
		return pStratificationMethod;
	}
	
	public ParserRule getStratificationMethodRule() {
		return getStratificationMethodAccess().getRule();
	}
	
	//TrainingTest:
	//	name='TrainingTest' '{'
	//	'pourcentageTraining' number=FLOAT
	//	'}';
	public TrainingTestElements getTrainingTestAccess() {
		return pTrainingTest;
	}
	
	public ParserRule getTrainingTestRule() {
		return getTrainingTestAccess().getRule();
	}
	
	//enum ValidationMetric:
	//	RECALL='recall' | PRECISION='precision' | F1;
	public ValidationMetricElements getValidationMetricAccess() {
		return eValidationMetric;
	}
	
	public EnumRule getValidationMetricRule() {
		return getValidationMetricAccess().getRule();
	}
	
	//terminal ID:
	//	'^'? ('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//	'"' ('\\' . | !('\\' | '"'))* '"' |
	//	"'" ('\\' . | !('\\' | "'"))* "'";
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT:
	//	'/*'->'*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT:
	//	'//' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER:
	//	.;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}
